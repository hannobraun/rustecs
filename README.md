# Rustecs

## About

Rustecs is an [Entity/Component System](http://entity-systems.wikidot.com/)
written in [Rust](http://rust-lang.org). It's being used to develop
[Von Neumann Defense Force](http://vndf.de).

Please note that while Rustecs works and is usable, it comes with one caveat.
I'm currently developing it for the needs of one specific game, which brings a
few limitations:
- It's usable but incomplete. I only implement features I actually need and know
  how to design. Some features you would expect from a generic entity system
  aren't there yet. For some missing features I use crazy workarounds in my own
  code because I'm not sure yet how to design a generic API for them yet.
- Performance is good enough but probably not better. I usually go with the
  simplest solution for a given problem without worrying about performance too
  much. So far that has worked well for me, but it might not be enough for you.

If you tried Rustecs and find it lacking, feel free to send me a pull request
that addresses your concerns!


## Documentation

### Introduction

The documentation in this README is intended to explain the general concepts of
Rustecs and how they should be used. To see an actual example, please take a
look at the unit tests:
https://github.com/hannobraun/rustecs/blob/master/rustecs/tests/


### The Basics

Rustecs is implemented as a compiler plugin that generates the code for your
entity system from declarations in a simple
[DSL](http://en.wikipedia.org/wiki/Domain-specific_language).

Here's what the definition for a simple Entity/Component System can look like.

``` Rust
world! {
	components Position, Size, Score;
}
```

We simply declare the three kinds of components we want to use and Rustecs
generates a lot of useful code for us.


### Components

The example is not complete though, since we haven't defined what the components
actually are. Components are just pieces of data. They can be any of Rust's data
types.

The following type definitions are required to complete the example.

``` Rust
// Regular struct
#[deriving(Clone, Decodable, Encodable, PartialEq, Show)]
struct Position {
	x: i16,
	y: i16,
}

// Tuple struct
#[deriving(Clone, Decodable, Encodable, PartialEq, Show)]
struct Size(u16);

// Simple type definition
type Score = u32;
```

As you can see, Rustecs expects components to implement a bunch of basic traits.
This is quite useful, since it allows Rustecs to derive those traits for the
data structures it implements, enabling us to do a lot of interesting things
with them.

You might ask yourself why we're defining `Score` as `u32` and not just use
`u32` directly in the world definition above. While that should work (I haven't
actually tried it), it's not recommended. As we will see, the name of the
component's type is used to generate other names, for example the names of the
collections the components are stored in.

You might also have different components that might be represented by the same
type, so you need the type alias to distinguish between them. Here's an example
of what this might look like:

``` Rust
// Two different component types that are represented by the same Rust type.
type Score  = u32;
type Health = u32;
```


### Entities

So far we haven't declared anything about entities. Doesn't Rustecs need to know
which types of entities we want to work with?

Well, no. Rustecs doesn't care. In Rustecs, entities are just an id number that
identifies the components that are part of that entity, and the "type" of an
entity is solely defined by the components it has.

The following example shows what creating components looks like.


``` Rust
// Here's the world definition from the example above. I'm not going to repeat
// the type declarations, but they have to be in scope for this to work.
world! {
	components Position, Size, Score;
}

// world! { ... } generates a type called World. Let's create a new world.
let mut world = World::new();

// Let's create a bunch of entites for our player to interact with. Like World,
// Entity is a data structure generated by the world! macro.
world.add_entity(
	Entity::new()
		.with_position(8, 12)
		.with_size(3)
);
world.add_entity(
	Entity::new()
		.with_position(-5, 2)
		.with_size(5)
);

// Here we create the entity representing the player.
world.add_entity(
	Entity::new()
		.with_position(0, 0)
		.with_score(0)
);


// The add_entity method return the id of the created entity. We can use that
// to destroy the entity later.
let entity_id = world.add_entity(Entity::new().with_position(10, 10));
world.remove_entity(entity_id);
```

If you find yourself repeating the same entity creation code everywhere, you can
just wrap that in a function.

``` Rust
fn complicated_entity(x: f32, y: f32) -> Entity {
	// Maybe you can generate some additional arguments here randomly!

	Entity::new()
		.with_position(x, y)
		.with_a(some_arguments)
		.with_b(other_arguments)
		.with_c(yet_another_argument)
}

...

world.add_entity(complicated_entity(5, 10));
```



### Systems

We know how to define entity constructors and components, so we have all the
tools we need to populate our world with data. What we haven't done is to
actually do something with that data.

In an ECS, the logic of a game is implemented in systems. Systems are just
functions that operate on a set of entities. Those entities are defined by the
components they have.

As I'm writing this Rustecs doesn't have direct support for systems yet (I'm
working on it), but of course you can still write systems that operate on your
entities (otherwise Rustecs would be pretty much useless).

Let's take a look at a simple world.

``` Rust
world! {
	components Position, Velocity;
}

type Position = Vector;
type Velocity = Vector;

struct Vector {
	x: i16,
	y: i16,
}
```

Let's add a bunch of cars to our world. Maybe this is a racing game?

``` Rust
fn main() {
	// Create a world and add a bunch of cars to it.
	let world = World::new();
	world.create_car(Entity::new().with_position(0, 0).with_velocity(10, 0));
	world.create_car(Entity::new().with_position(0, 3).with_velocity(10, 0));
	world.create_car(Entity::new().with_position(0, 6).with_velocity(10, 0));

	// Do something with the cars.
	...
}
```

Of course, cars are no good if they don't move, so let's write a system for
that.

``` Rust
fn move_cars(positions: Components<Position>, velocities: Components<Velocity>) {
	for (entity_id, position) in positions.iter_mut() {
		if !velocities.contains_key(entity_id) {
			// There might be entities that have a position but no velocity.
			// Ignore those.
			continue;
		}

		// If we have both a position and a velocity, it's a car and supposed to
		// move!
		let velocity = velocities[entity_id];
		position.x += velocity.x;
		position.y += velocity.y;
	}
}
```

The system iterates over all entities with a `Position` component, checks if the
entity also has a `Velocity` component and integrates the position, if it has.
Currently, `Components<T>` is simply defined as `HashMap<EntityId, T>`.

So how do we call that system? Let's complete our main function from above.

``` Rust
fn main() {
	// Create a world and add a bunch of cars to it.
	let world = World::new();
	world.create_car(Entity::new().with_position(0, 0).with_velocity(10, 0));
	world.create_car(Entity::new().with_position(0, 3).with_velocity(10, 0));
	world.create_car(Entity::new().with_position(0, 6).with_velocity(10, 0));

	// Do something with the cars.
	loop {
		// For each component type we defined, the world has a collection. We
		// just pass those to the systems.
		move_cars(world.positions, world.velocities);

		// In a real game, we'd do other stuff in this loop, like gathering
		// player input and rendering the cars.
	}
}
```

As you can see, the facilities for using systems are pretty basic. I already
have some plans for adding proper system support to Rustecs, but I need some
time to finalize the design and implement it.


### That's It!

There are some additional feaures I haven't talked about here, like importing
and exporting entities, but as far as basic use cases go, that's pretty much it.

If you have any questions, feel free to [contact me](mailto:mail@hannobraun.de).


## License

Copyright (c) 2014, Hanno Braun

Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
